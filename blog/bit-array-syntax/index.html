<!doctype html>
<html lang="en"><head><meta charset="UTF-8"><title>Making the Most of Bit Arrays | Gears</title><link href="/main.css" rel="stylesheet"><link href="https://rsms.me/" rel="preconnect"><link href="https://rsms.me/inter/inter.css" rel="stylesheet"><link href="/favicon.svg" rel="icon" type="image/svg+xml"><link href="/favicon.ico" rel="alternate icon" sizes="48x48" type="image/png"><link href="/apple-touch-icon.png" rel="apple-touch-icon" sizes="192x192"></head><body><header><nav><a href="/"><figure><img alt="Gears logo" height="64" src="/images/logo.svg" style="image-rendering:optimizeSpeed;image-rendering:pixelated;" width="64"><figcaption><svg xmlns="http://www.w3.org/2000/svg"><path xmlns="http://www.w3.org/2000/svg" class="write" d="m 46.655648,87.273021 c 0.08105,4.602277 0.692125,6.832404 4.69733,4.361206 l 1.696146,2.728148 -14.225762,9.638735 c -2.121146,-1.55607 -3.838276,-4.0442 -4.678364,-7.342384 -3.390161,3.734254 -7.562386,6.271464 -13.082724,5.788494 C 10.581627,101.53029 2.8720353,90.133692 1.4418114,77.915968 0.26959238,64.592176 8.4519982,56.762609 16.647423,50.627146 c 6.709353,-4.814367 12.185664,-6.592535 16.425926,-6.221561 10.400636,0.909937 10.2848,16.055858 17.661218,12.831577 l 1.369105,2.78015 -13.921761,7.085583 C 29.896397,65.974923 28.524127,49.408937 19.629655,55.241389 c -4.548238,3.149245 -6.106269,8.978614 -4.24704,19.057204 1.461159,6.335369 5.770507,14.209799 12.214927,17.030887 2.403158,1.097035 4.205262,0.770993 6.046357,-0.922122 l 0.08399,-0.960053 0.300983,-3.440212 c -4.7513,-0.980005 -7.300468,-2.251058 -10.07761,0.0051 L 22.053124,83.749873 33.3637,74.259168 c 9.7606,0.853945 14.332923,4.801125 19.271184,0.879838 l 1.905129,2.18211 -7.907394,7.450543 c -0.0043,0.967047 0.07203,1.94111 0.02303,2.501151 z m 27.106123,0.967939 c 3.255101,3.879267 7.924879,5.594901 14.610274,2.013462 L 89.84759,92.997687 71.511182,104.62772 C 62.371276,103.58301 53.002118,82.748534 59.5709,73.029912 61.983775,69.728218 72.927415,59.493724 79.332135,60.054064 85.49365,60.593125 92.577447,70.199104 92.109323,75.549881 Z M 70.902742,68.629587 c -3.536763,2.141364 -1.750046,9.73174 1.253752,15.549655 L 79.558343,78.94493 C 78.612783,73.878931 74.248977,66.798328 70.902742,68.629587 Z m 62.806708,23.029124 1.74528,2.221251 -13.08952,10.709588 c -2.6179,0 -5.2358,-4.839141 -5.71178,-8.567661 l -11.7409,8.567661 c -6.505075,-0.0794 -10.709601,-7.61571 -9.916305,-13.24816 1.269292,-8.250355 9.123005,-13.010178 19.832605,-16.104062 -3.49054,-5.553124 -13.08951,-4.997811 -19.0393,-1.348612 l -1.586601,-2.459244 14.993441,-10.78893 c 9.28166,0 19.19795,1.665941 19.43593,14.438129 l 0.0794,12.375534 c -0.0794,4.125169 1.26928,6.901741 4.99782,4.204506 z m -22.60914,3.490534 4.99781,-3.252544 -0.0794,-12.930849 c -10.23362,3.728531 -10.70961,12.930849 -4.91847,16.183393 z m 51.19467,-16.075266 c -2.21157,-3.712255 -5.13397,-8.846224 -8.45131,-5.765843 l -0.47391,0.473911 v 1.184756 l 0.079,12.795432 c -0.079,4.028194 1.18475,6.555693 4.897,3.949214 l 1.81664,2.448509 -13.0324,10.504892 c -3.55428,-2.21157 -6.23973,-6.792636 -6.16074,-13.664255 V 78.679058 c -0.15797,-4.818028 -1.97461,-6.397712 -6.63468,-3.396316 L 132.99186,72.755248 147.13,60.907625 c 3.08039,2.290541 4.89704,4.423114 5.68687,7.740447 l 8.05639,-7.740447 c 6.00279,0 11.68966,9.636068 11.68966,9.636068 z m 19.14678,-9.156439 c 4.4536,7.601839 23.80372,5.375035 23.80372,20.962647 0,10.442913 -10.13577,13.207223 -19.5037,13.207223 -7.14112,0 -13.8983,-2.45716 -16.12512,-6.757188 l 11.36438,-10.596498 1.84287,1.45894 c -2.91787,2.841084 11.134,6.987545 15.05009,6.987545 0.46073,-6.296472 -26.33768,-10.058994 -26.33768,-19.580489 0,-8.369699 13.89831,-14.05188 13.89831,-14.05188 7.83221,0 16.2019,4.4536 21.11622,1.61251 l 1.22858,1.689298 -12.90008,10.289358 c -4.99112,0 -11.44115,-8.292917 -13.43759,-5.221466 z" style="fill:none;stroke:#ffffff;stroke-width:1px;stroke-dasharray:330;stroke-dashoffset:330;"></path></svg></figcaption></figure></a></nav></header><main><h1>Making the Most of Bit Arrays</h1><div><h2 class="date">18 December, 2025</h2><p>Gleam has a special piece of syntax that most other languages don&#39;t: Bit arrays.
Taken from Erlang, bit array syntax allows the constructing and pattern matching
on binary data. Bit arrays are extremely powerful, but unfortunately the documentation
is <a href="https://tour.gleam.run/data-types/bit-arrays/" target="_blank">a little sparse</a>. It lists all
the possible options you can use, as well as linking to the Erlang documentation
for further reading, but the syntax isn&#39;t exactly the same as on Erlang, so there&#39;s
some ambiguity as to how it exactly works. To make it easier, I wanted to write a
comprehensive guide, to make it as easy as possible to understand how they work.</p><h3 id="table-of-contents">Table of contents</h3><hr><ul><li><p><a href="#the-basics" target>The basics</a></p></li><li><p><a href="#segment-types" target>Segment types</a></p></li><li><p><a href="#segment-size" target>Segment size</a></p></li><li><p><a href="#endianness" target>Endianness</a></p></li><li><p><a href="#pattern-matching" target>Pattern Matching</a></p><ul><li><p><a href="#strings" target>Strings</a></p></li><li><p><a href="#bits-and-bytes" target>Bits and Bytes</a></p></li><li><p><a href="#signedness" target>Signedness</a></p></li></ul></li><li><p><a href="#javascript-support" target>JavaScript support</a></p></li><li><p><a href="#example" target>Example</a></p></li></ul><hr><h2 id="the-basics">The basics</h2><p>Bit arrays are delimited by double angle brackets (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>), and contain zero
or more <strong>segments</strong>, separated by commas. A segment is a value which is encoded
somehow as a sequence of bits. They have no actual separation other than syntactically,
they are just a way of building up a bit array out of various different parts.</p><p>A segment consists of a value, followed by a series of options using the syntax
<code>value:option1-option2-option3</code>.</p><p>There are several different data types that can appear as the value of a bit
array segment, and each has a slightly different set of defaults, as well as
options that can be used to modify how it is encoded.</p><p>The default assumed type is <code>Int</code>, and if you want a segment that is a non-integer,
you need to specify that by using the type-specific option, unless you are using
a literal, in which case it is inferred automatically.</p><h2 id="segment-types">Segment types</h2><p>As mentioned above, the default segment type is <code>Int</code>. By default, integer
segments are encoded as an 8-bit signed integer, although this can be modified
using various options, which will be mentioned later.</p><p>The syntax for printing bit arrays with the <code>echo</code> keyword uses 8-bit unsigned
integer segments to represent the structure of the bit array, so that is what I
will be using in the rest of this article to show the encoding of various bit
arrays.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;1, 2, -3&gt;&gt;
// &lt;&lt;1, 2, 253&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>-3</span>&gt;&gt;
<span class=hl-comment>// &lt;&lt;1, 2, 253&gt;&gt;</span>
</span></code></pre></div><p>Bit array syntax also allows for <code>Float</code> segments. If you are not using a literal
float value, the <code>float</code> option is required for the program to type-check. By
default, floats are encoded as 64-bit <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank">IEEE 754</a>
floats, although the size can be changed to either 32 or 16 bit.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;3.14&gt;&gt;
// &lt;&lt;64, 9, 30, 184, 81, 235, 133, 31&gt;&gt;

let some_float = 1.0
echo &lt;&lt;some_float&gt;&gt;
// Error: Expected type Int, found type Float

echo &lt;&lt;some_float:float&gt;&gt;
// &lt;&lt;63, 240, 0, 0, 0, 0, 0, 0&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>3.14</span>&gt;&gt;
<span class=hl-comment>// &lt;&lt;64, 9, 30, 184, 81, 235, 133, 31&gt;&gt;</span>

<span class=hl-keyword>let</span> some_float = <span class=hl-number>1.0</span>
<span class=hl-keyword>echo</span> &lt;&lt;some_float&gt;&gt;
<span class=hl-comment>// Error: Expected type Int, found type Float</span>

<span class=hl-keyword>echo</span> &lt;&lt;some_float:float&gt;&gt;
<span class=hl-comment>// &lt;&lt;63, 240, 0, 0, 0, 0, 0, 0&gt;&gt;</span>
</span></code></pre></div><p>Strings are another data type that can be used as a bit array segment. By default,
strings are encoded in <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank">UTF-8</a>, although this
can be changed using the <code>utf16</code> and <code>utf32</code> options. The <code>utf8</code> option can also
be used, when the value is not a literal.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;&quot;Hello üåç&quot;&gt;&gt;
// &lt;&lt;72, 101, 108, 108, 111, 32, 240, 159, 140, 141&gt;&gt;

echo &lt;&lt;&quot;Hello üåç&quot;:utf16&gt;&gt;
// &lt;&lt;0, 72, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 216, 60, 223, 13&gt;&gt;

echo &lt;&lt;&quot;Hello üåç&quot;:utf32&gt;&gt;
// &lt;&lt;0, 0, 0, 72, 0, 0, 0, 101, 0, 0, 0, 108, 0, 0, 0, 108, 0, 0, 0, 111, 0, 0, 0, 32, 0, 1, 243, 13&gt;&gt;

let greeting = &quot;Hello&quot;
echo &lt;&lt;greeting&gt;&gt;
// Error: Expected type Int, found type String

echo &lt;&lt;greeting:utf8&gt;&gt;
// &lt;&lt;72, 101, 108, 108, 111&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-string>&quot;Hello üåç&quot;</span>&gt;&gt;
<span class=hl-comment>// &lt;&lt;72, 101, 108, 108, 111, 32, 240, 159, 140, 141&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-string>&quot;Hello üåç&quot;</span>:utf16&gt;&gt;
<span class=hl-comment>// &lt;&lt;0, 72, 0, 101, 0, 108, 0, 108, 0, 111, 0, 32, 216, 60, 223, 13&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-string>&quot;Hello üåç&quot;</span>:utf32&gt;&gt;
<span class=hl-comment>// &lt;&lt;0, 0, 0, 72, 0, 0, 0, 101, 0, 0, 0, 108, 0, 0, 0, 108, 0, 0, 0, 111, 0, 0, 0, 32, 0, 1, 243, 13&gt;&gt;</span>

<span class=hl-keyword>let</span> greeting = <span class=hl-string>&quot;Hello&quot;</span>
<span class=hl-keyword>echo</span> &lt;&lt;greeting&gt;&gt;
<span class=hl-comment>// Error: Expected type Int, found type String</span>

<span class=hl-keyword>echo</span> &lt;&lt;greeting:utf8&gt;&gt;
<span class=hl-comment>// &lt;&lt;72, 101, 108, 108, 111&gt;&gt;</span>
</span></code></pre></div><p>UTF codepoints, using the built-in <code>UtfCodepoint</code> type, are also possible to use
as bit array segments. These work similar to strings, but only represent a single
codepoint instead of multiple. Like strings, they can be encoded as UTF-8, UTF-16
or UTF-32, although they have differently named options: <code>utf8_codepoint</code>,
<code>utf16_codepoint</code> and <code>utf32_codepoint</code>. Since there are no UTF codepoint literals,
on of these options is always required.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert [codepoint] = string.to_utf_codepoints(&quot;üåç&quot;)

echo &lt;&lt;codepoint&gt;&gt;
// Error: Expected type Int, found type UtfCodepoint

echo &lt;&lt;codepoint:utf8_codepoint&gt;&gt;
// &lt;&lt;240, 159, 140, 141&gt;&gt;

echo &lt;&lt;codepoint:utf16_codepoint&gt;&gt;
// &lt;&lt;216, 60, 223, 13&gt;&gt;

echo &lt;&lt;codepoint:utf32_codepoint&gt;&gt;
// &lt;&lt;0, 1, 243, 13&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> [codepoint] = <span class=hl-module>string</span>.<span class=hl-function>to_utf_codepoints</span>(<span class=hl-string>&quot;üåç&quot;</span>)

<span class=hl-keyword>echo</span> &lt;&lt;codepoint&gt;&gt;
<span class=hl-comment>// Error: Expected type Int, found type UtfCodepoint</span>

<span class=hl-keyword>echo</span> &lt;&lt;codepoint:utf8_codepoint&gt;&gt;
<span class=hl-comment>// &lt;&lt;240, 159, 140, 141&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;codepoint:utf16_codepoint&gt;&gt;
<span class=hl-comment>// &lt;&lt;216, 60, 223, 13&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;codepoint:utf32_codepoint&gt;&gt;
<span class=hl-comment>// &lt;&lt;0, 1, 243, 13&gt;&gt;</span>
</span></code></pre></div><p>The last data type that can be used is <code>BitArray</code>. The encoding here is pretty
obvious, simply consisting of the bits inside the specified bit array. Bit array
segments must use the <code>bits</code> option.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let bit_array = &lt;&lt;3, 4, 5&gt;&gt;

echo &lt;&lt;bit_array&gt;&gt;
// Error: Expected type Int, found type BitArray

echo &lt;&lt;bit_array:bits&gt;&gt;
// &lt;&lt;3, 4, 5&gt;&gt;

echo &lt;&lt;1, 2, bit_array:bits, 6&gt;&gt;
// &lt;&lt;1, 2, 3, 4, 5, 6&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> bit_array = &lt;&lt;<span class=hl-number>3</span>, <span class=hl-number>4</span>, <span class=hl-number>5</span>&gt;&gt;

<span class=hl-keyword>echo</span> &lt;&lt;bit_array&gt;&gt;
<span class=hl-comment>// Error: Expected type Int, found type BitArray</span>

<span class=hl-keyword>echo</span> &lt;&lt;bit_array:bits&gt;&gt;
<span class=hl-comment>// &lt;&lt;3, 4, 5&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, bit_array:bits, <span class=hl-number>6</span>&gt;&gt;
<span class=hl-comment>// &lt;&lt;1, 2, 3, 4, 5, 6&gt;&gt;</span>
</span></code></pre></div><h2 id="segment-size">Segment size</h2><p>Possibly the most commonly used bit array option is <code>size</code>. The <code>size</code> option
allows you to customise the size that a particular segment has, specified in
bits.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;1024:size(16)&gt;&gt;
// &lt;&lt;4, 0&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>1024</span>:<span class=hl-function>size</span>(<span class=hl-number>16</span>)&gt;&gt;
<span class=hl-comment>// &lt;&lt;4, 0&gt;&gt;</span>
</span></code></pre></div><p>Since size is so commonly used, it even has a shorthand syntax that you can use,
where the <code>size</code> part is omitted:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;1.0:32&gt;&gt;
// &lt;&lt;63, 128, 0, 0&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>1.0</span>:<span class=hl-number>32</span>&gt;&gt;
<span class=hl-comment>// &lt;&lt;63, 128, 0, 0&gt;&gt;</span>
</span></code></pre></div><p>There is another option you can use in conjunction with <code>size</code>: <code>unit</code>. The <code>unit</code>
option allows you to specify a value that is multiplied by the size. This is most
commonly useful for specifying sizes in bytes, but can be used for any size unit.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`echo &lt;&lt;1024:2-unit(8)&gt;&gt;
// &lt;&lt;4, 0&gt;&gt;

echo &lt;&lt;12:3-unit(2)&gt;&gt;
// &lt;&lt;12:6&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>1024</span>:<span class=hl-number>2</span><span class=hl-operator>-</span><span class=hl-function>unit</span>(<span class=hl-number>8</span>)&gt;&gt;
<span class=hl-comment>// &lt;&lt;4, 0&gt;&gt;</span>

<span class=hl-keyword>echo</span> &lt;&lt;<span class=hl-number>12</span>:<span class=hl-number>3</span><span class=hl-operator>-</span><span class=hl-function>unit</span>(<span class=hl-number>2</span>)&gt;&gt;
<span class=hl-comment>// &lt;&lt;12:6&gt;&gt;</span>
</span></code></pre></div><p><em>For bit arrays which are not a whole number of bytes, the trailing bits at the
end are suffixed with the number of bits.</em></p><p>There are some limitations to the <code>size</code> option though. While it is unrestricted
on integer segments, float segments only support sizes of <code>16</code>, <code>32</code> or <code>64</code>, as
other size floats are not well defined.</p><p>String and UTF codepoint segments cannot use the <code>size</code> option; they have a fixed
size based on their value.</p><p>Bit array segments can use the <code>size</code> option to truncate the bit array to a
particular size, but if the specified size is larger than the size of the bit
array, it will lead to a runtime error.</p><h2 id="endianness">Endianness</h2><p>By default, bit array segments are <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">big endian</a>,
however it is possible to configure them to be little endian instead, using the
<code>little</code> option. There is a <code>big</code> option too, but it does nothing other than
perhaps making the intention of the code clearer. There is also <code>native</code>, which
chooses endianness based on the processor that is running the code.</p><p>Endianness is easiest to understand when it comes to integer segments, but it
also applies to <code>Float</code>s as well as UTF-16 and UTF-32 strings and codepoints.
It is not allowed for UTF-8 or bit array segments.</p><p>Endianness usually doesn&#39;t matter when using bit arrays internally; it is often
only useful when it comes to interacting with a predefined API.</p><h2 id="pattern-matching">Pattern matching</h2><p>The syntax shown until now has been for constructing bit arrays, but as mentioned
at the beginning, bit array syntax can also used to pattern match on binary data
and extract information from it. The syntax is largely the same, but there are
some limitations and additional features when it comes to pattern matching.</p><p>In general, most of the syntax that can be used when constructing bit arrays can
be used in the same way when pattern matching. You can either match on a specific
literal, or assign the value to a variable.</p><p>One thing to note is that segment information is not stored in the bit array, so
for example a <code>Float</code> segment can be matched on as an <code>Int</code>, and vice versa.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert &lt;&lt;x, y, z&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;
echo #(x, y, z)
// #(1, 2, 3)

let assert &lt;&lt;1, a, 3&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;
echo a
// 2

let assert &lt;&lt;x, y&gt;&gt; = &lt;&lt;3.14:16&gt;&gt;
echo #(x, y)
// #(66, 72)

let assert &lt;&lt;float:float-size(16)&gt;&gt; = &lt;&lt;60, 0&gt;&gt;
echo float
// 1.0
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;x, y, z&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>&gt;&gt;
<span class=hl-keyword>echo</span> #(x, y, z)
<span class=hl-comment>// #(1, 2, 3)</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;<span class=hl-number>1</span>, a, <span class=hl-number>3</span>&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>&gt;&gt;
<span class=hl-keyword>echo</span> a
<span class=hl-comment>// 2</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;x, y&gt;&gt; = &lt;&lt;<span class=hl-number>3.14</span>:<span class=hl-number>16</span>&gt;&gt;
<span class=hl-keyword>echo</span> #(x, y)
<span class=hl-comment>// #(66, 72)</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;float:float<span class=hl-operator>-</span><span class=hl-function>size</span>(<span class=hl-number>16</span>)&gt;&gt; = &lt;&lt;<span class=hl-number>60</span>, <span class=hl-number>0</span>&gt;&gt;
<span class=hl-keyword>echo</span> float
<span class=hl-comment>// 1.0</span>
</span></code></pre></div><h3 id="strings">Strings</h3><p>One restriction to note is that arbitrary length strings cannot be matched on in
this way. The following is an error:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert &lt;&lt;message:size(5)&gt;&gt; = &lt;&lt;&quot;Hello&quot;&gt;&gt;
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;message:<span class=hl-function>size</span>(<span class=hl-number>5</span>)&gt;&gt; = &lt;&lt;<span class=hl-string>&quot;Hello&quot;</span>&gt;&gt;
</span></code></pre></div><p>Because UTF-8 is variable sized, there&#39;s no guarantee that any given sequence
of bytes is valid UTF-8. You can still match on UTF codepoints though, as well
as string literals.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert &lt;&lt;&quot;Hello&quot;, last_char&gt;&gt; = &lt;&lt;&quot;Hello!&quot;&gt;&gt;
echo last_char
// 33

let assert &lt;&lt;first:utf8_codepoint&gt;&gt; = &lt;&lt;81&gt;&gt;
echo first
// utfcodepoint(Q)
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;<span class=hl-string>&quot;Hello&quot;</span>, last_char&gt;&gt; = &lt;&lt;<span class=hl-string>&quot;Hello!&quot;</span>&gt;&gt;
<span class=hl-keyword>echo</span> last_char
<span class=hl-comment>// 33</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;first:utf8_codepoint&gt;&gt; = &lt;&lt;<span class=hl-number>81</span>&gt;&gt;
<span class=hl-keyword>echo</span> first
<span class=hl-comment>// utfcodepoint(Q)</span>
</span></code></pre></div><h3 id="bits-and-bytes">Bits and bytes</h3><p>For matching on bit arrays, there are two options: The <code>bits</code> option that is used
in construction, and a second <code>bytes</code> option, which only matches whole numbers of
bytes. If given an explicit size, that number of bits/bytes is matched. If the
<code>size</code> option is not used, they match everything remaining in the bit array.</p><p><strong>Note</strong>: When using the <code>bytes</code> option, size is measured in bytes, and the <code>unit</code>
option cannot be used. This is currently a bug in Gleam, you can track its status
<a href="https://github.com/gleam-lang/gleam/issues/5208" target="_blank">here</a>.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert &lt;&lt;_, bits:bits-size(12), _:size(4)&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;
echo bits
// &lt;&lt;2, 0:4&gt;&gt;

let assert &lt;&lt;_, bytes:bytes-size(3), _&gt;&gt; = &lt;&lt;1, 2, 3, 4, 5&gt;&gt;
echo bits
// &lt;&lt;2, 3, 4&gt;&gt;

let assert &lt;&lt;first:4, rest:bits&gt;&gt; = &lt;&lt;1, 2, 3&gt;&gt;
echo rest
// &lt;&lt;16, 32, 3:4&gt;&gt;

let assert &lt;&lt;_, _, rest:bytes&gt;&gt; = &lt;&lt;1, 2, 3, 4, 5, 6&gt;&gt;
echo rest
// &lt;&lt;3, 4, 5, 6&gt;&gt;

let assert &lt;&lt;value:bytes&gt;&gt; = &lt;&lt;1, 2:2, 3&gt;&gt;
// Error: Pattern match failed
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;_, bits:bits<span class=hl-operator>-</span><span class=hl-function>size</span>(<span class=hl-number>12</span>), _:<span class=hl-function>size</span>(<span class=hl-number>4</span>)&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>&gt;&gt;
<span class=hl-keyword>echo</span> bits
<span class=hl-comment>// &lt;&lt;2, 0:4&gt;&gt;</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;_, bytes:bytes<span class=hl-operator>-</span><span class=hl-function>size</span>(<span class=hl-number>3</span>), _&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>, <span class=hl-number>4</span>, <span class=hl-number>5</span>&gt;&gt;
<span class=hl-keyword>echo</span> bits
<span class=hl-comment>// &lt;&lt;2, 3, 4&gt;&gt;</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;first:<span class=hl-number>4</span>, rest:bits&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>&gt;&gt;
<span class=hl-keyword>echo</span> rest
<span class=hl-comment>// &lt;&lt;16, 32, 3:4&gt;&gt;</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;_, _, rest:bytes&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>, <span class=hl-number>3</span>, <span class=hl-number>4</span>, <span class=hl-number>5</span>, <span class=hl-number>6</span>&gt;&gt;
<span class=hl-keyword>echo</span> rest
<span class=hl-comment>// &lt;&lt;3, 4, 5, 6&gt;&gt;</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;value:bytes&gt;&gt; = &lt;&lt;<span class=hl-number>1</span>, <span class=hl-number>2</span>:<span class=hl-number>2</span>, <span class=hl-number>3</span>&gt;&gt;
<span class=hl-comment>// Error: Pattern match failed</span>
</span></code></pre></div><h3 id="signedness">Signedness</h3><p>When matching on integers, they are treated by default as unsigned. If you want
to match on a signed integer, the <code>signed</code> option can be used, and the number is
interpreted using <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two&#39;s complement</a>.
The <code>unsigned</code> option also exists for consistency, but like <code>big</code>, it does
nothing. Signedness only applies to integers and cannot be used with any other
type of segment.</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`let assert &lt;&lt;x&gt;&gt; = &lt;&lt;-1&gt;&gt;
echo x
// 255

let assert &lt;&lt;x:signed&gt;&gt; = &lt;&lt;255&gt;&gt;
echo x
// -1
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;x&gt;&gt; = &lt;&lt;<span class=hl-number>-1</span>&gt;&gt;
<span class=hl-keyword>echo</span> x
<span class=hl-comment>// 255</span>

<span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> &lt;&lt;x:signed&gt;&gt; = &lt;&lt;<span class=hl-number>255</span>&gt;&gt;
<span class=hl-keyword>echo</span> x
<span class=hl-comment>// -1</span>
</span></code></pre></div><h2 id="javascript-support">JavaScript support</h2><p>Bit arrays are a feature of Erlang, built in to the BEAM virtual machine. This
is what inspired the Gleam feature, and it means we get all this behaviour for
free on the Erlang target. But on JavaScript, all features need to be implemented
from scratch. While most of the Erlang behaviour already exists, a few features
are still lacking. At the time of writing the two missing features are the
<code>native</code> option, and pattern matching on UTF codepoints. You can check the
<a href="https://github.com/gleam-lang/gleam/issues/3842" target="_blank">tracking issue</a> to see if any
progress has been made since.</p><h2 id="example">Example</h2><p>Now that we know about all the features of bit arrays, we can use them. Here is
an example of a basic en/decoder for Minecraft&#39;s <a href="https://minecraft.wiki/w/NBT_format" target="_blank">NBT</a>
format, using bit arrays.</p><p>First, we define our type to represent the NBT data:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`pub type Nbt {
  Byte(Int)
  Short(Int)
  Int(Int)
  Long(Int)
  Float(Float)
  Double(Float)
  ByteArray(List(Int))
  IntArray(List(Int))
  LongArray(List(Int))
  String(String)
  List(List(Nbt))
  Compound(Dict(String, Nbt))
}
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>pub</span> <span class=hl-keyword>type</span> <span class=hl-variant>Nbt</span> {
  <span class=hl-variant>Byte</span>(<span class=hl-variant>Int</span>)
  <span class=hl-variant>Short</span>(<span class=hl-variant>Int</span>)
  <span class=hl-variant>Int</span>(<span class=hl-variant>Int</span>)
  <span class=hl-variant>Long</span>(<span class=hl-variant>Int</span>)
  <span class=hl-variant>Float</span>(<span class=hl-variant>Float</span>)
  <span class=hl-variant>Double</span>(<span class=hl-variant>Float</span>)
  <span class=hl-variant>ByteArray</span>(<span class=hl-variant>List</span>(<span class=hl-variant>Int</span>))
  <span class=hl-variant>IntArray</span>(<span class=hl-variant>List</span>(<span class=hl-variant>Int</span>))
  <span class=hl-variant>LongArray</span>(<span class=hl-variant>List</span>(<span class=hl-variant>Int</span>))
  <span class=hl-variant>String</span>(<span class=hl-variant>String</span>)
  <span class=hl-variant>List</span>(<span class=hl-variant>List</span>(<span class=hl-variant>Nbt</span>))
  <span class=hl-variant>Compound</span>(<span class=hl-variant>Dict</span>(<span class=hl-variant>String</span>, <span class=hl-variant>Nbt</span>))
}
</span></code></pre></div><p>Next, we can create a <code>decode</code> function to turn a bit array into NBT:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`pub fn decode(bits: BitArray) -&gt; Nbt {
  // The first byte tells us what kind of data the value is
  case bits {
    &lt;&lt;1, byte:8-signed, _:bits&gt;&gt; -&gt; Byte(byte)
    &lt;&lt;2, short:16-signed, _:bits&gt;&gt; -&gt; Short(short)
    &lt;&lt;3, int:32-signed, _:bits&gt;&gt; -&gt; Int(int)
    &lt;&lt;4, long:64-signed, _:bits&gt;&gt; -&gt; Long(long)
    &lt;&lt;5, float:32-float, _:bits&gt;&gt; -&gt; Float(float)
    &lt;&lt;6, double:64-float, _:bits&gt;&gt; -&gt; Double(double)

    &lt;&lt;8, length:32, bytes:bytes-size(length), _:bits&gt;&gt; -&gt; {
      // We can&#39;t match on arbitrary UTF-8 so we must extract the bytes then
      // convert it to a string.
      let assert Ok(string) = bit_array.to_string(bytes)
      String(string)
    }

    &lt;&lt;7, length:32-signed, bytes:bytes-size(length), _:bits&gt;&gt; -&gt;
      ByteArray(bytes_to_list(bytes, 8, []))

    &lt;&lt;11, length:32-signed, bytes:bytes-size(length * 4), _:bits&gt;&gt; -&gt;
      IntArray(bytes_to_list(bytes, 32, []))

    &lt;&lt;12, length:32-signed, bytes:bytes-size(length * 8), _:bits&gt;&gt; -&gt;
      LongArray(bytes_to_list(bytes, 64, []))

    // Omitted for brevity
    &lt;&lt;9, _:bits&gt;&gt; -&gt; todo
    &lt;&lt;10, _:bits&gt;&gt; -&gt; todo
    // For the sake of this example, we will just crash the program here
    _ -&gt; panic as &quot;Invalid NBT&quot;
  }
}
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>pub</span> <span class=hl-keyword>fn</span> <span class=hl-function>decode</span>(bits: <span class=hl-variant>BitArray</span>) -&gt; <span class=hl-variant>Nbt</span> {
  <span class=hl-comment>// The first byte tells us what kind of data the value is</span>
  <span class=hl-keyword>case</span> bits {
    &lt;&lt;<span class=hl-number>1</span>, byte:<span class=hl-number>8</span><span class=hl-operator>-</span>signed, _:bits&gt;&gt; -&gt; <span class=hl-variant>Byte</span>(byte)
    &lt;&lt;<span class=hl-number>2</span>, short:<span class=hl-number>16</span><span class=hl-operator>-</span>signed, _:bits&gt;&gt; -&gt; <span class=hl-variant>Short</span>(short)
    &lt;&lt;<span class=hl-number>3</span>, int:<span class=hl-number>32</span><span class=hl-operator>-</span>signed, _:bits&gt;&gt; -&gt; <span class=hl-variant>Int</span>(int)
    &lt;&lt;<span class=hl-number>4</span>, long:<span class=hl-number>64</span><span class=hl-operator>-</span>signed, _:bits&gt;&gt; -&gt; <span class=hl-variant>Long</span>(long)
    &lt;&lt;<span class=hl-number>5</span>, float:<span class=hl-number>32</span><span class=hl-operator>-</span>float, _:bits&gt;&gt; -&gt; <span class=hl-variant>Float</span>(float)
    &lt;&lt;<span class=hl-number>6</span>, double:<span class=hl-number>64</span><span class=hl-operator>-</span>float, _:bits&gt;&gt; -&gt; <span class=hl-variant>Double</span>(double)

    &lt;&lt;<span class=hl-number>8</span>, length:<span class=hl-number>32</span>, bytes:bytes<span class=hl-operator>-</span><span class=hl-function>size</span>(length), _:bits&gt;&gt; -&gt; {
      <span class=hl-comment>// We can&#39;t match on arbitrary UTF-8 so we must extract the bytes then</span>
      <span class=hl-comment>// convert it to a string.</span>
      <span class=hl-keyword>let</span> <span class=hl-keyword>assert</span> <span class=hl-variant>Ok</span>(string) = <span class=hl-module>bit_array</span>.<span class=hl-function>to_string</span>(bytes)
      <span class=hl-variant>String</span>(string)
    }

    &lt;&lt;<span class=hl-number>7</span>, length:<span class=hl-number>32</span><span class=hl-operator>-</span>signed, bytes:bytes<span class=hl-operator>-</span><span class=hl-function>size</span>(length), _:bits&gt;&gt; -&gt;
      <span class=hl-variant>ByteArray</span>(<span class=hl-function>bytes_to_list</span>(bytes, <span class=hl-number>8</span>, []))

    &lt;&lt;<span class=hl-number>11</span>, length:<span class=hl-number>32</span><span class=hl-operator>-</span>signed, bytes:bytes<span class=hl-operator>-</span><span class=hl-function>size</span>(length <span class=hl-operator>*</span> <span class=hl-number>4</span>), _:bits&gt;&gt; -&gt;
      <span class=hl-variant>IntArray</span>(<span class=hl-function>bytes_to_list</span>(bytes, <span class=hl-number>32</span>, []))

    &lt;&lt;<span class=hl-number>12</span>, length:<span class=hl-number>32</span><span class=hl-operator>-</span>signed, bytes:bytes<span class=hl-operator>-</span><span class=hl-function>size</span>(length <span class=hl-operator>*</span> <span class=hl-number>8</span>), _:bits&gt;&gt; -&gt;
      <span class=hl-variant>LongArray</span>(<span class=hl-function>bytes_to_list</span>(bytes, <span class=hl-number>64</span>, []))

    <span class=hl-comment>// Omitted for brevity</span>
    &lt;&lt;<span class=hl-number>9</span>, _:bits&gt;&gt; -&gt; <span class=hl-keyword>todo</span>
    &lt;&lt;<span class=hl-number>10</span>, _:bits&gt;&gt; -&gt; <span class=hl-keyword>todo</span>
    <span class=hl-comment>// For the sake of this example, we will just crash the program here</span>
    _ -&gt; <span class=hl-keyword>panic</span> <span class=hl-keyword>as</span> <span class=hl-string>&quot;Invalid NBT&quot;</span>
  }
}
</span></code></pre></div><p>The <code>bytes_to_list</code> splits a bit array into n-bit chunks:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`fn bytes_to_list(bytes: BitArray, chunk_size: Int, out: List(Int)) -&gt; List(Int) {
  case bytes {
    &lt;&lt;first:size(chunk_size)-signed, rest:bytes&gt;&gt; -&gt;
      bytes_to_list(rest, chunk_size, [first, ..out])
    _ -&gt; list.reverse(out)
  }
}
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>fn</span> <span class=hl-function>bytes_to_list</span>(bytes: <span class=hl-variant>BitArray</span>, chunk_size: <span class=hl-variant>Int</span>, out: <span class=hl-variant>List</span>(<span class=hl-variant>Int</span>)) -&gt; <span class=hl-variant>List</span>(<span class=hl-variant>Int</span>) {
  <span class=hl-keyword>case</span> bytes {
    &lt;&lt;first:<span class=hl-function>size</span>(chunk_size)<span class=hl-operator>-</span>signed, rest:bytes&gt;&gt; -&gt;
      <span class=hl-function>bytes_to_list</span>(rest, chunk_size, [first, ..out])
    _ -&gt; <span class=hl-module>list</span>.<span class=hl-function>reverse</span>(out)
  }
}
</span></code></pre></div><p>Finally, an <code>encode</code> function to turn the NBT back into binary:</p><div class="codeblock"><button class="copy-button" onclick="navigator.clipboard.writeText(`pub fn encode(nbt: Nbt) -&gt; BitArray {
  case nbt {
    Byte(byte) -&gt; &lt;&lt;1, byte:8&gt;&gt;
    Short(short) -&gt; &lt;&lt;2, short:16&gt;&gt;
    Int(int) -&gt; &lt;&lt;3, int:32&gt;&gt;
    Long(long) -&gt; &lt;&lt;4, long:64&gt;&gt;
    Float(float) -&gt; &lt;&lt;5, float:float-32&gt;&gt;
    Double(double) -&gt; &lt;&lt;6, double:float-64&gt;&gt;

    // Append the tag (7), followed by each byte in the list
    ByteArray(bytes) -&gt;
      list.fold(bytes, &lt;&lt;7&gt;&gt;, fn(out, byte) { &lt;&lt;out:bits, byte:8&gt;&gt; })
    IntArray(ints) -&gt;
      list.fold(ints, &lt;&lt;11&gt;&gt;, fn(out, int) { &lt;&lt;out:bits, int:32&gt;&gt; })
    LongArray(longs) -&gt;
      list.fold(longs, &lt;&lt;12&gt;&gt;, fn(out, long) { &lt;&lt;out:bits, long:64&gt;&gt; })

    String(string) -&gt; &lt;&lt;8, string:utf8&gt;&gt;

    // Omitted for brevity
    List(_) -&gt; todo
    Compound(_) -&gt; todo
  }
}
`)">copy</button><pre><code data-lang="gleam"><span><span class=hl-keyword>pub</span> <span class=hl-keyword>fn</span> <span class=hl-function>encode</span>(nbt: <span class=hl-variant>Nbt</span>) -&gt; <span class=hl-variant>BitArray</span> {
  <span class=hl-keyword>case</span> nbt {
    <span class=hl-variant>Byte</span>(byte) -&gt; &lt;&lt;<span class=hl-number>1</span>, byte:<span class=hl-number>8</span>&gt;&gt;
    <span class=hl-variant>Short</span>(short) -&gt; &lt;&lt;<span class=hl-number>2</span>, short:<span class=hl-number>16</span>&gt;&gt;
    <span class=hl-variant>Int</span>(int) -&gt; &lt;&lt;<span class=hl-number>3</span>, int:<span class=hl-number>32</span>&gt;&gt;
    <span class=hl-variant>Long</span>(long) -&gt; &lt;&lt;<span class=hl-number>4</span>, long:<span class=hl-number>64</span>&gt;&gt;
    <span class=hl-variant>Float</span>(float) -&gt; &lt;&lt;<span class=hl-number>5</span>, float:float<span class=hl-operator>-</span><span class=hl-number>32</span>&gt;&gt;
    <span class=hl-variant>Double</span>(double) -&gt; &lt;&lt;<span class=hl-number>6</span>, double:float<span class=hl-operator>-</span><span class=hl-number>64</span>&gt;&gt;

    <span class=hl-comment>// Append the tag (7), followed by each byte in the list</span>
    <span class=hl-variant>ByteArray</span>(bytes) -&gt;
      <span class=hl-module>list</span>.<span class=hl-function>fold</span>(bytes, &lt;&lt;<span class=hl-number>7</span>&gt;&gt;, <span class=hl-keyword>fn</span>(out, byte) { &lt;&lt;out:bits, byte:<span class=hl-number>8</span>&gt;&gt; })
    <span class=hl-variant>IntArray</span>(ints) -&gt;
      <span class=hl-module>list</span>.<span class=hl-function>fold</span>(ints, &lt;&lt;<span class=hl-number>11</span>&gt;&gt;, <span class=hl-keyword>fn</span>(out, int) { &lt;&lt;out:bits, int:<span class=hl-number>32</span>&gt;&gt; })
    <span class=hl-variant>LongArray</span>(longs) -&gt;
      <span class=hl-module>list</span>.<span class=hl-function>fold</span>(longs, &lt;&lt;<span class=hl-number>12</span>&gt;&gt;, <span class=hl-keyword>fn</span>(out, long) { &lt;&lt;out:bits, long:<span class=hl-number>64</span>&gt;&gt; })

    <span class=hl-variant>String</span>(string) -&gt; &lt;&lt;<span class=hl-number>8</span>, string:utf8&gt;&gt;

    <span class=hl-comment>// Omitted for brevity</span>
    <span class=hl-variant>List</span>(_) -&gt; <span class=hl-keyword>todo</span>
    <span class=hl-variant>Compound</span>(_) -&gt; <span class=hl-keyword>todo</span>
  }
}
</span></code></pre></div></div></main><footer>Made with <a href="https://lustre.build" target="_blank">Lustre</a> and <a href="https://gleam.run" target="_blank">Gleam</a><br>Source: <a href="https://github.com/GearsDatapacks/GearsDatapacks.github.io" target="_blank">GitHub</a></footer></body></html>